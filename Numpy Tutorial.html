<html>
    <head>
        <title>
             Python ==> Numpy Tutorial
        </title>
    </head>
    <body>
        <pre>
            <code>
                  ***** Python - NumPy Tutorial *****

            ==> Numpy is a general-purpose array-processing package. 
                It provides a high-performance multidimensional array object, and tools for working with these arrays. 
                It is the fundamental package for scientific computing with Python 

            ==> What is an Array : 

                 An Array is a datastructure that stores values of same data type. 
                 In Python, this is the main difference between arrays and lists. 
                 While python lists can contain values corresponding to different data types, arrays in python 
                 can only contain values corresponding to same datatype. 
              
            ==> NumPy is a fundamental package for numerical computing in python. 
                It provides support for multidimensional arrays and matrices, along with a collection of mathematical function 
                to operate on these arrays effeciently. 

              ==> Key Feature of NumPy include : 

                 1. N-dimensional Arrays :  NumPy's main object is the homogeneous multidimensional array called ndarray. 
                    These arrays can have any number of dimensions and contain elements of the same datatype. 

                 2. Efficient Operations : NumPy provides a wide range of mathematical functions that operate element-wise on arraysm 
                    enabling efficient numerical operartions. 

                 3. Broadcasting :  NumPy's broadcasting capability allows operations between arrays of different shapes and sizes without 
                    explicitly iterating over them, which can greatly simplify code and improve performance 

                 4. Indexing and Slicing : NumPy offers powerful indexing and slicing capabilities for accessing and modifying elements within arrays 
                     including advanced techniques like boolean  indexing and fancy indexing 

                 5. Integration with Other Libraries : NumPy is the foundation for many other scientific computing libraries in Python, such as SciPy, Matplotlib, 
                 and scikit-learn. It seamlessly integrates with these libraries, providing a cohesive ecosystem for scientific computing. 

                 Importing NumPy : 
                 ----------------- 

                 import numpy as np 



               ==> NumPy ->   Numerical Python 
               
                Lists and Tuples are in-built data types in python 

                  Advantages of Numpy Arrays over lists and tuples  : 
                  ------------------------------------------------- 

                  1. Allows several Mathematical Operations. 

                  2. Faster Operations. 


                  import numpy as np 

              List Vs Numpy - Time taken
              ----------------------------- 

                  from time import process_time 
 
              Time taken by a list:
              --------------------- 

                 python_list = [i for i in range(1000)]

                 start_time = process_time()

                 python_list = [i+5 for i in python_list]

                 end_time = process_time()

                 print(end_time - start_time)

              Time taken by a Numpy Array :
              ------------------------------ 

                np_array = np.array([i for i in range(1000)])

                start_time = process_time()

                np_array += 5 // np_array = np_array + 5

                end_time = process_time()

                print(end_time - start_time) 


        ==>   Numpy Arrays : 
             ---------------- 

             #list 

             list1 = [1,2,3,4,5]

             print(list1) // [1,2,3,4,5]

             type(list1) // list1 
             
             #NumPy Arrays (ndarrays) : 

             NumPy arrays, or ndarrays, are the primary datastructure used in NumPy. 
             They are homogeneous collections of elements with fixed dimensions and 
             have many similarities to Python list but with additional functionality optimized for 
             numerical computing. 

             1D Arrays : 

             1D Arrays are like traditional arrays or lists. They have a single row and can be indexed using a single index. 

             # create a 1D array  
              arr_1d = np.array([1,2,3,4,5])
              print(arr_1d) # [1 2 3 4 5]
              print(arr_1d[0]) # 1 

             2D Arrays : 

             2D Arrays, aslo knowm as matrices, have rows and columns. 
             They are indexed using two indices, one for row and one for the column 

             # create a 2D array 
               arr_2d = np.array([[1, 2, 3],
                                  [4, 5, 6],
                                  [7, 8, 9])

               print(arr_2d)
               [[1 2 3]
                [4 5 6]
                [7 8 9]]

             # Properties of nd Arrays : 

             1. Shape : 
                The Shape of an ndarray describes the size of each dimension of the array. 
                It is represented as atuple of integers indicating the number of elements along each dimension. 

                # create a 2D array 

                arr_2d = np.array([[1,2,3], 
                                   [4,5,6]])

                # print the shape 
                print("Shape of the array : ", arr_2d.shape) # Output : shape of the array : (2,3)
             
             2. Data Type(dtype) :
                 
                 The data type of an ndarray specifies the type of elements stored in the array. 
                 NumPy arrays can hold elements of different types such as integers, float, boolean,etc., 

                 # create an array with a specific data type 
                   
                    arr_float = np.array([1.1,2.2,3.3], dtype = np.float32)

                 # Print the data type 
                    
                     print("Data type of the array:", arr_float.dtype) # Output : Data type of the array : float32 

                     arr_float = np.array([1.1,2.2,3.3], dtype = np.int32)

                     print(arr_float) # [1 2 3]
                     print("Data type of the array:", arr_float.dtype) # Output : Data type of the array : int32
                     

                3. Size : 
                      
                     The Size of an ndarray is the total number of elements in the array. 
                     It is equal to the product of the dimensions of the array. 

                  # create a 3D array 
                       arr_3d = np.zeros((2,3,4)) # 2 layers => z -axis | 3 layers => y - axis | 4 layers => x - axis
                       print(arr_3d) 
                       print(arr_3d.dtype)

                  # Print the size 
                        print("Size of the array : ", arr_3d.size) # Output : 24 ( 2 * 3 * 4) 
                        
                       [
                        [ [0. 0. 0. 0.]
                          [0. 0. 0. 0.]
                          [0. 0. 0. 0.]
                        ]
                         
                        [ [0. 0. 0. 0.]
                          [0. 0. 0. 0.]
                          [0. 0. 0. 0.]
                        ]
                       ]
                        
                      Size of the array : 24 
                      
                      
                  4. Number of Dimensions (ndim)
                        The ndim attribute of an ndarray specifies the number of dimensions or axes of the array. 

                        # create a 4D array 

                        arr_4d = np.ones((2, 3, 4, 5)) # 

                        # print the number of dimensions 

                        print("Number of dimensions:", arr_4d.ndim) # Output : 4 


                        
                   5. Itemsize : 

                        The itemsize attribute of an ndarray specifies the size of each element in bytes. 
                        
                        # create an array of integers 

                        arr_int = np.array([1,2,3])
                        print(arr_int.dtype)

                        # print the item size 
                        print("Size of each element (in bytes) : ", arr_int.itemsize) # Output : 8 (for 64-bit integer)

                        int64 
                        Size of each element (in bytes): 8


             3. NumPy Data types and precision : 

                  NumPy Data Types (dtypes) : 

                  NumPy provides a variety of datatypes to represent different kinds of numeric data. 
                  These data types are important for controlling memory usage and ensuring data integrity in numerical computations. 

                  Common Numpy Data Types: 
                      => int : Integer (default size depends on the platform)
                      => float : Floating point number (default size depends on the platform)
                      => bool : Boolean (True or False)
                      => complex : Complex number with real and imaginary parts 
                      => uint : Unsigned Integer (no neagtive values)

                 => Specifying Data types : 
                    
                     You can specify the data type of an ndarray using the dtype paramter of NumPy functions or 
                     providing the data type as an argument to the array creation functions. 

                       # create an array with aspecific data type 
                         arr_int32 = np.array([1,2,3], dtype = np.int32)
                         arr_float64 = np.array([1.1,2.2,3.3], dtype=np.float64)

                         print("Data type of arr_int32:", arr_int32.dtype) # output : int32 
                         print("Data type of arr_float64:", arr_float64.dtype) # Output : float64 

                 => Precision : 
                      
                        Precision refers to the level of detail and accuracy with numerical values are represented.
                        NumPy data types have different levels of precision, which determine the range of values they can represent and the amount of 
                        memory they occupy. 

                        # create an array with different data types 
                           arr_int32 = np.array([1234567890, 1234567890], dtype = np.int32)
                           arr_int64 = np.array([1234567890, 1234567890], dtype = np.int64)

                           print("Data type of arr_int32:", arr_int32.dtype) # Output : int32 
                           print("Data type of arr_int64:", arr_int64.dtype) # Output : int64 

                           print(arr_int32) # [1234567890, 1234567890]

                          * In this example, the 'int32' data type has limited precision compared to 'int64', which can represent 
                            larger integers without loss of precision.


                      => Impact of precision on Memory Usage : 

                          # create arrays with different data types : 

                             arr_float32 = np.array([1.1,2.2,3.3], dtype = np.float32)
                             arr_float64 = np.array([1.1,2.2,3.3], dtype = np.float64)

                             print("Memory usage of arr_float32 : ", arr_float32.itemsize * arr_float32.size, "bytes") # Output : 12 bytes (3 elements * 4 bytes per element)
                             print("Memory usage of arr_float64 : ", arr_float64.itemsize * arr_float64.size, "bytes") # Output : 24 bytes (3 elements * 6 bytes per element)
                      
                             Output : 

                             Memory usage of arr_float32 : 12 bytes 
                             Memory usage of arr_float64 : 24 bytes 
                      
                      => Example differentiating float32 and float64 : 

                         # Create a large array with float32 and float64 data types 
                           large_array_float32 = np.arange(1000000, dtype = np.float32)
                           large_array_float64 = np.arange(1000000, dtype = np.float64)

                         # Calculate the sum of elements 
                            sum_float32 = np.sum(large_array_float32)
                            sum_float64 = np.sum(large_array_float64)

                          print("Sum using float32 : ", sum_float32)
                          print("Sum using float64 : ", sum_float64)

                          Output : 

                          Sum using float32 : 499999800000.0 
                          Sum using float64 : 499999500000.0 # more precise than float32 because float64 has more memory space so it store precise values 

                4. np.zeros , np.ones, np.full : 

                    np.zeros creates an array filled with zeros. It takes the shape of the desired array as input and returns an array of that shape filled with zeros. 
                    
                    Syntax : 

                            numpy.zeros(shape, dtype=float)

                            shape : The shape of the array (tuple of integers).
                            dtype : Opional. The datatype of the array. Default is float. 

                            # creates a 2 * 3array filled with zeros 
                            zeros_array = np.zeros((2,3))
                            print(zeros_array)

                    Output : 
                             [ [0. 0. 0.]
                               [0. 0. 0.]]
                             float64 

                    np.ones : 

                      np.ones creates an array filled with ones.Similar to np.zeros, it takes the shape of the desired array as input and 
                      returns an array of that shape filled with ones. 

                      Syntax : 

                              numpy.ones(shape,dtype=None)

                              shape : The shape of the array (tuple of integers)
                              dtype : Optional. The data type of the array. If not specified, the default is determined by the datatype of 1. 

                              # create a 3 * 2 array filled with ones 

                              ones_array = np.ones((3,2))
                              print(ones_array)

                              Output : 
                                 [[1. 1.]
                                  [1. 1.]
                                  [1. 1.]
                                 ]
                      np.full : 

                         np.full creates an array filled with a specified constant value. It takes the shape of the desired array and the constant value as 
                         input and returns an array of that shape filled with the specified value. 

                         Syntax : 
                          
                                numpy.full(shape, fill_value, dtype=None)

                                Shape : The shape of the array(tuple of integers)
                                fill_value : The constant value to fill the array with. 
                                dtype : Optional. The data type of the array. If not specified, the default is determined by the datatype of fill_value. 

                                # create a 2 * 2 array filled with 5 

                                full_array = np.full((2,2),5)
                                print(full_array) 

                                Output : 

                                [ [5 5]
                                  [5 5]
                                ]

                  5. Array Operations - NumPy 

                     5.1 Arithmetic Operations : 
                          
                        # Addition : 

                          arr_sum = np.add([1,2,3], [4,5,6])
                          print("Addition : ", arr_sum) # Output : [5 7 9]

                        # Subtraction : 

                           arr_diff = np.subtract([5,6,7],[2,3,1])
                           print("Subtraction : ", arr_diff) # Output : [3 3 6]

                        # Multiplication : 

                           arr_mul = np.multiply([2,3,4],[3,4,5])
                           print("Multiplication : ", arr_mul) # Output : [6 12 20]

                        # Division : 
                         
                            arr_div = np.divide([10,12,14],[2,3,2])
                            print("Division : ", arr_div) # Output : [5. 4. 7.]

                        # Modulus : 

                            arr_mod = np.mod([10,11,12],[3,4,5])
                            print("Modulus : ", arr_mod) # Output : [1 3 2]

                        # Exponentiation : 
                          
                            arr_pow = np.power([2,3,4],[2,3,2])
                            print("Exponentiation : ", arr_pow) # Output : [4 27 16]

                      5.2 Relational Operations : 

                            # Create sample arrays 
                             
                            arr1 = np.array([1, 2, 3, 4])
                            arr2 = np.array([2, 2, 4, 3])

                            # Equal 
                            print("Equal : ", arr1 == arr2) # Output : [False True False False] 

                            # Not Equal 
                            print("Not Equal : ", arr1 != arr2) # Output : [True False True True]

                            # Greater than 
                            print("Greater than : ", arr1 > arr2) # Output : [False False False True]

                            # Greater than or Equal to 
                            print("Greater than or Equal to : ", arr1 >= arr2) # Output : [False True False True]

                            # Less than 
                            print("Less than : ", arr1 < arr2) # Output : [True False False False]

                            # Less than or Equal to : 
                            print("Less than or Equal to : ", arr1 <= arr2) #Output : [True True True False]

                            # Note : both arrays hsape should be same otherwise there will be no output : 
                              arr1 = np.array([1, 2, 3, 4, 5])
                              arr2 = np.array([2, 2, 4, 4])
                              u will get an error:
                              valueError : operands could not be broadcast together with shapes (5,) (4,) 

                  6. Indexing and Slicing for 1D Arrays : 
                    
                       6.1 Indexing : 
                         
                            Indexing refers to accessing individual elements of an array using their position (index) within the array. 
                            In NumPy, indexing starts from 0, so the first element has index 0, the second element has index 1, and so on. 

                            # create a 1D array 
                              
                               arr = np.array([1, 2, 3, 4, 5])

                            # Access individual elements using indexing 
                             
                               print("First element : ", arr[0]) # Output : 1 
                               print("Second element : ", arr[1]) # Output : 2 
                               print("Last element : ", arr[-1]) # Output : 5 (negative indexing)

                        6.2 Slicing : 

                              Slicing allows you to extract a subset of elements from an array by specifing a range of indices. 
                              The basic syntax for slicing is 

                              start :  stop : step, where start is the starting index (inclusive) 
                                                          stop is the ending index (exclusive)
                                                          step is the step size 

                              # create a 1D array 
                              
                                arr = np.array([1,2,3,4,5])

                              # Slice elements from index 1 to index 3 (exclusive)

                                 print("Slice : ", arr[1:3]) # Output : [2 3]

                              # Slice elements from index 0 to index 4 with step size 2 

                                 print("Slice with step : ", arr[0 : 4 : 2]) # Output : [1 3]

                         6.3 Negative indexing : 

                                 Negative indexing allows you to access elements fromt the end of the array by specifying negatove indices.
                                  -1 refers to the last element ,
                                  -2 refers to the second last element, and so on 

                              # Create a 1D array 
                                
                                 arr = np.array([1, 2, 3, 4, 5])

                              # Access the lasr element using negative indexing 
                               
                                 print("Last element : ", arr[-1]) # Output : 5 

                         6.4  Slicing with Omitted Indices : 
                             
                                 You can omit any of the slicing paramters to use default values.
                                 Omitting start defaults to 0, omitting stop defaults to the end of the array,
                                 and omittinf step defaults to 1. 
                                 
                              # create a 1D array 

                                 arr = np.array([1,2,3,4,5])

                              # Slice elements from the beginning to index 3 (exclusive)

                                print("Slice with omitted start : ", arr[:3]) # Output : [1 2 3]

                              # Slice elements from index 2 to the end 

                                print("Slice with omitted stop : ", arr[2:]) # Output : [3 4 5]

                              # Slice elements woth step size 2 

                                print("Slice with omitted step : ", arr[::2]) # Output : [1 3 5]

                  7. Indexing and slicing for 2D Arrays : 

                          7.1 Indexing : 

                          Indexing refers to accessing individual elements of an array using their position (index) within the array. 
                          In a 2D array, indexing is done using rows and columns. 

                             # create a 2D array 

                                arr = np.array([1, 2, 3],
                                               [4, 5, 6],
                                               [7, 8, 9])

                             # Access individual elements using indexing 

                                print("Element at (0,0) : ", arr[0,0]) 0 row 0 column # Output : 1 
                                print("Element at (1,2) : ", arr[1,2]) 1st row 2 column # Output : 6 

                           7.2 Slicing : 

                           Slicing allows you to extract a subset of elements from an array by specifying ranges of row and column indices. 
                           The basic syntax for slicing is 

                           start : stop : step, where start is the starting index (inclusive)
                                                      stop is the ending index (exclusive)
                                                      step is the step size 

                             # create a 2D array 

                                arr = np.array([ [1, 2, 3],
                                                 [4, 5 , 6],
                                                 [7, 8, 9]
                                               ])

                                # Slicing elements form rows 0 to 1 (exclusive) and columns 1 to 2 (exclusive)
                                   print("Slice : ", arr[0:2, 1:3])

                                   Output : 

                                   Slice : [[2 3]
                                            [5 6]
                                           ]

                                # Modify Slice 
                                  arr[0:2, 1:3] = [[10,20],[30,40]]
                                  print("Modified array after slicing :", arr)

                                  Output : 

                                  Modified array after slicing : 

                                  [[1 10 20]
                                   [4 30 40]
                                   [7  8  9]
                                  ]

                           7.3 Negative Indexing : 

                               Negative Indexing can also be used in 2D arrays to access elements from the end of the array. 

                               # create a 2D array 

                                arr = np.array([ [1, 2, 3],
                                                 [4, 5 , 6],
                                                 [7, 8, 9]
                                               ])

                               # Access the last element using negative indexing 
                                 print("Last element : ", arr[-1, -1]) # Output : 9 
                                  print("Last element : ", arr[-3, -1]) # Output : 3 

                           7.4 Slicing with Omitted Indices : 

                                You can omit any of the slicing parameters to use default values. 
                                Omitting start defaults to 0, 
                                omitting stop defaults to the end of the array, and 
                                omitting step defaults to 1. 

                                # create a 2D array 
                                  arr = np.array([[1, 2, 3],
                                                  [4, 5, 6],
                                                  [7, 6, 9]])

                                # Slice elements from rows 1 to the end and all columns 
                                   print("Slice with omitted start and stop : ", arr[1:]) # Output : [[4 5 6] [7 8 9]]

                                # Slice elements from all rows and columns 0 to 1 (exclusive) with step size 2 
                                    print("Slice with omitted step : ", arr[:, 0:2:2]) # Output : [[1]
                                                                                                   [4]
                                                                                                   [7]
                                                                                                  ]
                  8. Mass Level Indexing and Slicing : 

                     8.1 Boolean Indexing : 

                        Boolean Indexing allows you to select elements from an array based on a condition. 
                        You create a boolean mask indicating which elements satisfy the condition, and then use this mask 
                        to extract the desired elements. 

                        # create a 1D array 
                           
                           arr_1d = np.array([1,2,3,4,5])

                        # Boolean mask for elements greater than 3 

                           mask = arr_1d > 3    

                         # use Boolean mask to select elements 
                         
                            selected_elements = arr_1d[mask]
                            print("Slected elements : ", selected_elements) # [4 5]

                        Explaination :  [1, 2, 3, 4, 5]          arr_1d > 3
                                      False, False, True, True, True 

                        # create 2D array
                        
                             arr_2d = np.array([[1, 2, 3],        False True True
                                                [4, 5, 6],        True  True True 
                                                [7, 8, 9]         True  True True 
                                               ])

                        # Boolean indexing to select elements greater than 2 

                              result_2d = arr_2d[arr_2d > 2]
                              print("Elements greter than 2 in 2D array : ", result_2d) # Output : [3 4 5 6 7 8 9]

                      8.2 Fancy Indexing : 

                          Fancy Indexing allows you to select elements from an array using arrays of indices. 
                          You provide arrays of indices along each axis, and the elements at those indices are returned as a new array 

                           # Create a 1D array 

                             arr_1d = np.array([1,2,3,4,5])

                           # Fancy indexing 

                             indices = [0,2,4]
                             selected_elements = arr_1d[indices]
                             print("Selected elements : ", selected_elements) # Output : [1 3 5]

                   9. Playing with Arrays : 

                       9.1 Transposing Arrays : 
                           
                              Transposing an array means exchanging its rows and columns. 
                              In NumPy, you can transpose an array using the T attribute or the transpose() function. 

                              # create a 2D array 
                              arr_2d = np.array([ [1, 2, 3], 
                                                  [4, 5, 6]
                                               ])

                              print(arr_2d.shape) # (2, 3)

                              # Transpose the array 
                              transposed_arr = arr_2d.T 
                              print(arr_2d.shape) # (3,2)
                              print("Transposed array:")
                              print(transposed_arr)
                              #Output : 
                              [ [1 4]
                                [2 5]
                                [3 6]
                              ]

                        9.2 Swapping Axes : 

                                  Swapping axes means rearranging the dimensions of an array. You can swap axes using the swapaxes() function. 

                                # create a 2D array 
                                arr_2d = np.array([ [1, 2, 3],
                                                    [4, 5, 6]
                                                 ])

                                # Swap axes 
                                 swapped_arr = arr_2d.swapaxes(0,1)
                                 print("Swapped array:")
                                 print(swapped_arr) 

                                 Output :
                                 [[1 4]
                                  [2 5]
                                  [3 6]]

                                # Create a 3D array of shape (2, 3, 4)
                                # Think of it as 2 layers of 3 * 4 matrices. 

                                array_3d = np.array([[ [1, 2, 3, 4],
                                                       [5, 6, 7, 8],            # 1 layer
                                                       [9, 10, 11, 12] ],
                                                     [ [13, 14, 15, 16],
                                                       [17, 18, 19, 20],        # 2 layer
                                                       [21, 22, 23, 24]
                                                     ]
                                                   ])

                                 print("Original array shape: ", array_3d.shape) # (2,3,4)

                                 # Swap the first and last axes (depth with columns) 
                                    
                                    swapped_array = np.swapaxes(array_3d,0,2)  # 0axes 2axes we are swapping

                                 print("Swapped array shape:", swapped_array.shape) # (4,3,2)

                                 print("Swapped array data :", swapped_array)

                                 [[ [1 13]
                                    [5 17]
                                    [9 21]
                                  ]

                                  [ [2 14]
                                    [6 18]
                                    [10 22]
                                  ]

                                  [ [4 16]
                                    [8 20]
                                    [12 24]
                                  ]
                                 ]
                                                    /\
                                 |                  /
                                 |  0 axis         /  2 axis 
                                 |                /
                                \ /  -------------> 1 axis 

                        9.3 Pseudo-random Number Generation : 

                            NumPy provides various functions for generating pseudo-random numbers. 
                            These functions are located in the numpy.random module. 
                            You can generate random numbers from different distributions, such as uniform, normal,binomial.etc.,

                            # Pseudo-random Number Generation in 1D array : 

                            # Generate 5 random integers between 1 and 10 
                            random_integers = np.random.randint(1,10,size = 5)
                            print("Random integers (1D):", random_integers)

                            # Generate 5 random numbers from a normal distribution 
                            random_normal = np.random.normal(size=5)
                            print("Random numbers from normal distribution (1D):", random_normal)

                            #Output :

                            Random integers (1D) : [9 6 1 8 4]
                            Random numbers from normal distribution (1D) : [1.06863026  0.48286822 0.55086636 -0.02394996  0.72991067]

                            # Pseudo-random Number Generation in 2D Array : 

                            # Generate a 2D array of shape (3,3) with random integers between 1 and 10 

                            random_integers_2d = np.random.randint(1,10,size = (3,3))
                            print("Random integers (2D):")
                            print(random_integers_2d)

                            # Generate a 2D array of shape (3,3) with random numbers from a normal distribution 

                            random_normal_2d = np.random.normal(size = (3,3))
                            print("Random numbers from normal distribution (2D):")
                            print(random_normal_2d)

                            #Output : 
                            Random integers (2D):
                            [ [1 5 2]
                              [8 2 7] 
                              [1 3 9]
                            ]

                            Random numbers from normal distribution (2D):
                            [[-0.530259 -1.25998378   0.04791921]
                             [0.54604908 0.21002351  -0.75041193]
                             [0.18459713 -1.27315366 0.81455921]
                            ]


                  10. Operations on 2D Arrays : 

                      10.1 Matrix Multiplication (np.matmul()) : 

                      Matrix multiplication is a fundamental operation in linear algebra, where you multiply two matrices 
                      to obtain a new matrix. In NumPy, you can perform matrix multiplication using the np.matmul() function. 

                      # Define matrices : 
                      matrix_a = np.array([[1,2],[3,4]])
                      matrix_b = np.array([[5,6],[7,8]])

                      # Matrix multiplication using np.matmul()

                      result = np.matmul(matrix_a, matrix_b)
                      print("Matrix Multiplication : ")
                      print(result)

                      #Output : 

                      Matrix Multiplication :
                      [[19 22]
                       [43 50]
                      ]

                      10.2 Reshaping (np.reshape()) : 

                      Reshaping an array means changing the shape of the array without changing its data. 
                      It's useful for converting arrays between different dimensions or rearranging their layout. 

                      # Reshaping an array 
                      arr = np.arange(1,10) # 1D array from 1 to 9 
                      print(arr) # [1 2 3 4 5 6 7 8 9]

                      reshaped_Arr = arr.reshape((3,3)) # Reshape to a 3*3 matrix 
                      print("Reshaped array : ")
                      print(reshaped_arr)

                      #Output : 
                      [[1 2 3]
                       [4 5 6]
                       [7 8 9]
                      ]

                      Note : if you give (1,11) i.e 1 to 10 elements won't fit into the 3*3 matrix so we need to define 
                             right values that fits into a matrix 

                 
                      10.3 Transpose(np.transpose()) : 
 
                          Transposing a matrix means flipping its rows with its columns. 
                          In NumPy, you can obtain the transpose pf a matrix using the np.transpose() function or the .T attribute. 

                          # Transposing a matrix 
                          matrix = np.array([
                                            [1, 2, 3],
                                            [4, 5, 6]
                                           ])
                          
                           transposed_matrix = np.transpose(matrix)
                           print("Transposed matrix :")
                           print(transposed_matrix)

                           # Output : 
                           Transposed matrix : 
                           [ [1 4]
                             [2 5]
                             [3 6]
                           ]

                      10.4 Aggregate function : 

                          Aggregate function in NumPy are functions that operate on arrays and return a single value, 
                          summarizing the data in some way. Common aggregate functions include np.sum(), np.max(), np.min(),
                          np.mean(), etc., 

                          Aggregate functions : 

                          matrix = np.array([1, 2, 3],
                                            [4, 5, 6]
                                            )

                          print("Sum of all elements : ", np.sum(matrix)) # Output : 21 
                          print("Maximum element : ", np.max(matrix)) # Output : 6 
                          print("Minimum element : ", np.min(matrix)) # Output : 1 
                          print("Mean of all elements : ", np.mean(matrix)) # Output : 3.5
                           
                    
                  11. Universal Functions (ufuncs) : 

                      11.1 Basic Arithmetic Operations : 

                           # Create a sample array : 
                           arr = np.array([1, 2, 3, 4, 5])

                           # Element-wise addition 
                           result_add = np.add(arr,2) # Add 2 to each element 
                           print("Addition : ", result_add) # [3 4 5 6 7]

                           # Element-wise multiplication 
                           result_mul = np.multiply(arr,3) # Multiply each element by 3 
                           print("Multiplication : ", result_mul) # [3 6 9 12 15]


                       11.2 Triginimetric functions : 

                              # Trigonometric function : 

                               angles = np.array([0,np.pi/4, np.pi/2, 3*np.pi/4, np.pi])

                              # Sine 
                                result_sin = np.sin(angles)
                                print("Sine : ", result_sin)

                              # cosine 
                                result_cos = np.cos(angles)
                                print("Cosine : ", result_cos)

                        11.3 Exponential and Logarithmic Functions : 

                                # Exponential and Logarithmic functions : 

                                  arr = np.array([1, 2, 3, 4, 5])

                                # Exponential 
                                  
                                   result_exp = np.exp(arr) # exponential value 2.718 [e^1, e^2,....]
                                   print("Exponential : ", result_exp)

                                # Natural logarithm 

                                   result_log = np.log(arr)
                                   print("Natural logarithm : ", result_log)

                        11.4 Statistical functions : 

                                 # Statistical function :
                                   arr = np.array([1, 2, 3, 4, 5])

                                 # Mean 
                                   result_mean = np.mean(arr)
                                   print("Mean : ", result_mean) # 3.0 

                                 # standard deviation 
                                    result_std = np.std(arr)
                                    print("Standard deviation : ", result_std) # 1.41421356 

                         11.2 Comparison functions : 

                                 # Comparison functions 
                                    arr1 = np.array([1, 2, 3, 4, 5])
                                    arr2 = np.array([2, 3, 3, 4, 4])

                                 # Greater than 
                                     result_gt = np.greater(arr1, arr2)
                                     print("Greater Than : ", result_gt) # [False False False False False True]

                                 # Less than or equal to 
                                      result_lte = np.less_equal(arr1, arr2)
                                      print("Less than or equal to : ", result_lte) # [True True True True False]


                          11.6 Broadcasting : 

                                   Ufuncs also support broadcasting, which means they can operate on arrays of different shapes. 
                                   NumPy automatically broadcasts arrays to perform element-wise operations 

                                   arr = np.array([[1, 2, 3], [4, 5, 6]])

                                   # Element-wise addition with scalar 
                                   result_broadcast = arr + 2
                                   print("Broadcasting with scalar : ")
                                   print(result_broadcast)

                                   #Output : 
                                   [[3 4 5]
                                    [6 7 8]
                                   ]

                  12. Array Manipulation : 

                     **  Playing with Shapes : 

                     1. reshape :  The reshape method returns a new array with specified shape, without changing the data. 

                       # Create a one-dimensional array of 12 elements 
                          
                          a = np.arange(12)
                          print("Original array : ", a) # [0 1 2 3 4 5 6 7 8 9 10 11]

                       # Reshape it to a 3 * 4 two-dimensional array 
                         
                          b = a.reshape(3,4)
                          print("Reshaped array : ", b)

                          [ [0 1 2 3]
                            [4 5 6 7]
                            [8 9 10 11]
                          ]

                     2. resize : The resize method changes the shape and size of an array in-place. 
                          This method can alter the original array and fill in with repeated copies of a if the new array is larger than 
                          the original. 

                          # Resize the array in-place to 2 * 6 

                          a = np.arange(10)
                          a.resize(2,6)
                          print("Resized array : ") 
                          [ [0 1 2 3 4 5]
                            [6 7 8 9 0 0]
                          ]

                     3. ravel : The ravel method returns a flattened one-dimensional array. It's a convenient way to convert 
                                    any multi-dimensional array into a flat 1D array. 

                              # Flatten the 3*4 array to a one-dimensional array 

                              flat = b.ravel()
                              print("Flattened array : ", flat) # [0 1 2 3 4 5 6 7 8 9 10 11]

                     4. flatten : Similar to ravel, but flatten returns a copy instead of a view of the original data, thus not affecting the original array. 
                           
                              # Create a copy of flattened array 
                                flat_copy = b.flatten()
                                print("Flattened array copy :", flat_copy) # [0 1 2 3 4 5 6 7 8 9 10 11]

                     5. Difference between ravel and flatten : 

                             # creating a 2D array 
                                a = np.array([[1,2], [3,4]])

                             # Flattening using ravel 
                                b = a.ravel() 
                                b[0] = 100 # Modifying the raveled array 

                             # Flattening using flatten 
                                 c = a.flatten()
                                 c[1] = 200 # Modifying the flattened array 

                                print("Original array after modifying reveled array : ", a) # [[100 2] [3 4]]
                                print("Original array after modifying flattened array does not change : ", a) # [[100 2][3 4]]

                      6. Squeeze : The Squeeze method is used to remove axes of length one from an array  

                               # create an array with a singleton dimension 
                                c = np.array([[[1,2,3,4]]])
                                print("Original array with singleton dimension : ", c.shape) # (1,1,4)

                               # Squeeze to remove singelton dimension 
                                 squeezed = c.squeeze()
                                 print(squeezed)            # [1 2 3 4]
                                 print("Squeezed array : ", squeezed.shape) # (4, )

                      7. expand_dims : The Opposite of squeeze, expand_dims is used to add an axis at a specified position. 
                                  
                                 # Add an axis at index 1 
                                   expanded = np.expand_dims(squeezed, axis = 1) # squeezed value here is [1 2 3 4]
                                   print(expanded) 
                                   print("Expanded array shape : ", expanded.shape)

                                   # Output : 
                                   [[1]
                                    [2]
                                    [3]
                                    [4]
                                   ]
                                   Expanded array shape : (4,1)

                  13. Splitting and Joining : 

                          Splitting allows you to divide large arrays into smaller arrays. 
                          This can be useful for parallel processing tasks or during situations where subsets of data need to be analyzed separately. 

                          1. np.split : Splits an array into multiple sub-arrays. 

                             x = np.arange(9)
                             print("Original array : ", x) # [0 1 2 3 4 5 6 7 8]

                             # Split the array into 3 equal parts 
                             x_split = np.split(x,3)
                             print("Split array : ", x_split)

                          2. np.array_split : Similar to np.split, but allows for splitting into unequal subarrays. 
                              
                              # split the array into 4 parts, which will not be equal 
                              x_array_split = np.array_split(x, 4)
                              print("Array split into unequal parts : ", x_array_split)

                          3. 






                                



                          



                                  

                                

                                





                          








                         


                                     





                                

                             



                          

                            

                      
                        


                                  



                                

                          

                            


                       



                    
------------------------------------------------------------------------------------------------------
             np_array = np.array([1,2,3,4,5])

             print(np_array) // [1 2 3 4 5]
             type(np_array) // numpy.ndarray (nd means n-dimensional array)

             here arrays are similar to matrix 

             # creating a 1 dimensional array 

             a = np.array([1,2,3,4,5])

             print(a) // [1 2 3 4 5]

             a.shape // (5,) // here 5 is representing the number of columns 
             
             b = np.array([(1,2,3,4,5), (6,7,8,9,10)])

             print(b) // [ [1 2 3 4 5 ] 
                           [6 7 8 9 10]]


             b.shape // (2,4) // here the first number represents number of rows and second number represents number of columns. 
                                // so 2 represents number of rows and 4 represents number of columns
                        
             # with floating points 

             c = np.array([(1,2,3,4,5), (6,7,8,9,10)], dtype = float)
             print(c)  //  [ [1. 2. 3. 4. 5.] 
                            [6. 7. 8. 9. 10.]]

             
             # initial placholders in numpy arrays 

               # Create a numpy array of zeros
               
               x = np.zero((4,5))
               print(x)

               output : 

               [[0. 0. 0. 0. 0.]
                [0. 0. 0. 0. 0.]
                [0. 0. 0. 0. 0.]
                [0. 0. 0. 0. 0.]
               ]

               #  create a numpy array of ones 
               
                y = np.ones((3,3))
                print(y)

                output : 

                [[1. 1. 1.]
                 [1. 1. 1.]
                 [1. 1. 1.]
                ]

               # numpy array of a particular value 

               z = np.full((5,4),5)
               print(z) 

               output : 

               [[5 5 5 5]
                [5 5 5 5]
                [5 5 5 5]
                [5 5 5 5]
                [5 5 5 5]
               ]

              #  create an identity matrix : [ diagonal will be 1 and remaining all are zeros]
                 
               a = np.eye(4)  // here we are not to give rows and columns here as identity matrix have same rows and columns 
                            // so we will give one number only 

                print(a)

                [[1. 0. 0. 0.]
                 [0. 1. 0. 0.]
                 [0. 0. 1. 0.]
                 [0. 0. 0. 1.]
                ]

              # create a numpy array with random values  - default we will get decimal numbers (float) between 0 and 1

                b = np.random.random((3,4))
                print(b)

                [[0.06 0.03 0.04 0.07]
                 [0.7 0.08 0.09 0.1]
                 [0.02 0.6 0.5 0.2]
                ]

              # random integer values array within a specific range 

                c = np.random.randint(10,100,(3,5)) // here first and second number represents range of numbers (print values between these two numbers )
                                                    // (3,5) represents rows and columns 
                print(c)   

                [[24 82 43 91 73]
                 [98 11 52 38 38]
                 [13 68 44 21 11]
                ]

              # array of evenly spaced values -- specifying the number of values required

                d = np.linspace(10,30,6)
                print(d)

                [10. 14. 18. 22. 26. 30.]

              # array of evenly spaced values -- specifying the step 
              => np.arange() is a function in NumPy used to create an array with regularly spaced values with a specified range. Its syntax is : 

                numpy.arange([start,]stop,[step,] dtype=None)

                start : Optional. The start of the interval(Inclusive). Default is 0. 
                stop : The end of the interval. 
                step : Optional. The step size between values. Default is 1. 
                dtype : Optional. The data type of the array. If not specified, the datatype is inferred from the other input arguments. 
                
                # create an array from 0 to 9
                  arr = np.arange(10)
                  print(arr) # Output : [0 1 2 3 4 5 6 7 8 9]

                  new_arr = np.arange(4,10)
                  print(new_arr) # [4 5 6 7 8 9]

                e = np.arange(10,30,5)
                print(e)

                [10 15 20 25]

              # convert a list to a numpy array 

                 list2 = [10,20,20,20,50]

                 np_array = np.asarray(list2)
                 print(np_array)
                 type(np_array)

                 [10 20 20 20 50]
                 numpy.ndarray 

        ==> Analysing a numpy array : 
             --------------------------- 

             c = np.random.randint(10,90,(5,5))
             print(c)

             [[66 80 57 82 62]
              [61 81 62 75 65]
              [24 43 42 35 11]
              [64 70 50 80 45]
              [70 23 53 80 23]
             ]

            # array dimension 
              
              print(c.shape)

              (5,5)

            # number of dimensions 

              print(c.ndim)

              2 

            # number of elements in an array 

               print(c.size) 

               25 

            # checking the data type of the values in the array 

               print(c.dtype)

               int64

        ==> Mathematical operations on a np array : 
            --------------------------------------- 
            
            list1 = [1,2,3,4,5]
            list2 = [6,7,8,9,10]

            print(list1 + list2) // here when we use addition symbol it concatenate the two lists not adding element wise
                                 // concatenate or jouns two lists 

            [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

            a = np.random.randint(0,10,(3,3))
            b = np.random.randint(10,20,(3,3))

            print(a)
            print(b)
            
            [[7 2 0]
             [8 8 6]
             [5 7 0]]
            [[15 10 13]
             [18 14 14]
             [12 13 10]]

            print(a+b)
            
             [[22 12 13]
              [26 22 20]
              [17 20 10]]

            same as for other operations 

            print(a + b)
            print(a * b)
            print(a / b)

          # we can even use functions to perform same tasks like above

            print(np.add(a,b))
            print(np.subtract(a,b))
            print(np.multiply(a,b))
            print(np.divide(a,b))

        ==> Array Manipulation :
            -------------------- 
            
            array = np.random.randint(0,10,(2,3))
            print(array)
            print(array.shape)

            output : 

            [[1 2 2]
             [8 0 7]]

            (2,3)

            # transpose -- it will convert the rows into columns and viceversa
            
            trans = np.transpose(array)
            print(trans)
            print(trans.shape)

            output : 

            [[1 8]
             [2 0]
             [2 7]]

            (3, 2)

            # Another way to tranpose is using np.T 

            trans2 = array.T 
            print(trans2)
            print(trans2.shape)

            [[1 8]
             [2 0]
             [2 7]]

            (3, 2)

            # reshaping a array 

            a = np.random.randint(0,10, (2,3))

            print(a)
            print(a.shape)

            [[4 3 7]
             [4 6 6]
            ]

            (2,3)
         
            b = a.reshape(3,2)

            [[4 3]
             [7 4]
             [6 6]]

            (3, 2)

        


            </code>
        </pre>
    </body>
</html>